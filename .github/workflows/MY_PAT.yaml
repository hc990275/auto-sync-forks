name: Global Filename Fixer

on:
  workflow_dispatch: # ä»…æ‰‹åŠ¨è§¦å‘ï¼Œç‚¹å‡» Actions é¡µé¢é‡Œçš„ Run workflow è¿è¡Œ

jobs:
  fix-all-repos:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Fix All Repositories
        env:
          GH_TOKEN: ${{ secrets.MY_PAT }}
          USER_NAME: "hc990275"
          GIT_TERMINAL_PROMPT: 0  # ç»å¯¹ç¦æ­¢ Git åœ¨åå°å¡ä½ç­‰å¾…ä»»ä½•å¯†ç è¾“å…¥
        run: |
          pip install requests
          
          # æ³¨æ„ï¼šæ­¤å¤„çš„ 'EOF' ä½¿ç”¨äº†å•å¼•å·ï¼Œè¿™æå…¶å…³é”®ï¼
          # å®ƒç¡®ä¿äº†ä¸‹æ–¹çš„ Python ä»£ç ä¸­çš„åæ–œæ ï¼ˆå¦‚ '\'ï¼‰ åŸæ ·ä¼ å…¥ Pythonï¼Œä¸ä¼šè¢« Bash æå‰è½¬ä¹‰æ‰ã€‚
          # åŠ ä¸Š -u å‚æ•°å¼ºåˆ¶ python å®æ—¶æ‰“å°æ—¥å¿—ï¼ˆæ— ç¼“å†²ï¼‰ï¼Œä¸ç„¶åœ¨ Actions é‡Œå‰é¢çš„æ‰“å°å¯èƒ½ä¼šè¢«æ†‹ç€
          python -u - <<'EOF'
          import os
          import requests
          import subprocess
          import urllib.parse
          import shutil
          import sys
          import ast

          token = os.getenv('GH_TOKEN')
          username = os.getenv('USER_NAME')
          
          if not token:
              print("âŒ é”™è¯¯ï¼šæœªè®¾ç½® GH_TOKEN ç¯å¢ƒå˜é‡ï¼")
              exit(1)

          headers = {
              'Authorization': f'token {token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          subprocess.run(["git", "config", "--global", "user.name", "GitHub Action Bot"])
          subprocess.run(["git", "config", "--global", "user.email", "action@github.com"])
          # å¼€å¯ quotepath ä¸º true å…¶å®æ˜¯å¸Œæœ›ä¸‡ä¸€è¦ç”¨åˆ° git å‘½ä»¤ï¼Œä¹Ÿä¸è®©å®ƒè‡ªä½œèªæ˜çš„ç¿»è¯‘ï¼
          subprocess.run(["git", "config", "--global", "core.quotepath", "true"])

          # è·å–æ‰€æœ‰ä»“åº“
          repos = []
          page = 1
          while True:
              api_url = f"https://api.github.com/user/repos?per_page=100&type=owner&page={page}"
              print(f"æ­£åœ¨è·å–ç¬¬ {page} é¡µä»“åº“...")
              try:
                  response = requests.get(api_url, headers=headers)
                  response.raise_for_status()
                  page_repos = response.json()
                  if not page_repos:
                      break
                  repos.extend(page_repos)
                  page += 1
              except Exception as e:
                  print(f"âŒ è·å–ä»“åº“åˆ—è¡¨æ—¶å‡ºé”™: {e}")
                  exit(1)

          total_repos = len(repos)
          print(f"âœ… æˆåŠŸè·å–äº† {total_repos} ä¸ªä»“åº“çš„ä¿¡æ¯ï¼Œå‡†å¤‡å¼€å§‹å…¨å±€æ‰«æã€‚")

          def decode_name(name_str):
              """åªé’ˆå¯¹å•å±‚æ–‡ä»¶å/æ–‡ä»¶å¤¹åè¿›è¡Œè§£ç ï¼Œé˜²å½±å“æ•´ä½“è·¯å¾„"""
              decoded = name_str
              
              # ä¸æ–­å‰¥ç¦»å¯èƒ½å­˜åœ¨çš„å¤–å±‚åŒå¼•å·
              while decoded.startswith('"') and decoded.endswith('"') and len(decoded) >= 2:
                  decoded = decoded[1:-1]
              
              # 1. URL è§£ç  (é’ˆå¯¹ %E4%B8%AD è¿™ç§)
              if '%' in decoded:
                  try:
                      decoded = urllib.parse.unquote(decoded)
                  except:
                      pass
                      
              # 2. æ ¸å¿ƒï¼šå¤„ç†å…«è¿›åˆ¶æˆ–åå…­è¿›åˆ¶è½¬ä¹‰ï¼Œå°¤å…¶æ˜¯è¢«å½“åšçº¯å­—ç¬¦ä¸²å†™å…¥ç¡¬ç›˜çš„ \345
              if '\\' in decoded:
                  try:
                      temp = decoded.encode('latin-1').decode('unicode_escape')
                      decoded = temp.encode('latin-1').decode('utf-8')
                  except Exception:
                      pass
                      
                  if '\\' in decoded:
                      try:
                          mock_str = f'b"{decoded}"'
                          byte_val = ast.literal_eval(mock_str)
                          ast_decoded = byte_val.decode('utf-8')
                          if ast_decoded != decoded:
                              decoded = ast_decoded
                      except Exception:
                          pass
              
              return decoded

          # å¼€å§‹å¤„ç†æ¯ä¸€ä¸ªä»“åº“
          for repo_index, repo in enumerate(repos):
              repo_name = repo['name']
              
              repo_progress = (repo_index + 1) / total_repos * 100
              print(f"\n====================================")
              print(f">>> [æ€»ä½“è¿›åº¦: {repo_index + 1}/{total_repos} ({repo_progress:.1f}%)] æ­£åœ¨å¤„ç†ä»“åº“: {repo_name}")
              print(f"====================================")
              sys.stdout.flush() 
              
              clone_url = repo['clone_url'].replace("https://", f"https://{username}:{token}@")
              
              if os.path.exists('temp_repo'):
                  # å¤„ç†ç”±äº Windows ç­‰æƒé™æ‹’ç»å¼•å‘çš„ç›®å½•åˆ é™¤å¤±è´¥
                  try:
                      shutil.rmtree('temp_repo')
                  except:
                      subprocess.run(["rm", "-rf", "temp_repo"])
              
              if subprocess.run(["git", "clone", "--depth", "1", clone_url, "temp_repo"], capture_output=True).returncode != 0:
                  print(f"è¯¥ä»“åº“å…‹éš†å¤±è´¥: {repo_name}")
                  continue

              os.chdir('temp_repo')
              
              fixed_count = 0
              
              # ğŸš¨ ã€æ ¸å¿ƒé‡å¡‘ã€‘ï¼šæ”¾å¼ƒä½¿ç”¨ Git å·¥å…·æµï¼Git çš„ç¯å¢ƒé€‚åº”æ€§è‡ªä½œèªæ˜ä¼šåæ‰è½¬ä¹‰ã€‚
              # æˆ‘ä»¬ç›´æ¥æ‰«æç¡¬ç›˜é‡Œé¢æ‰€æœ‰å®é™…å­˜åœ¨çš„ä¸œè¥¿ã€‚
              paths_to_check = []
              for root, dirs, files in os.walk('.'):
                  # è·³è¿‡ .git æ–‡ä»¶å¤¹
                  if '.git' in root.split(os.sep):
                      continue
                      
                  # é‡åˆ°ä¹±ç çš„æ–‡ä»¶å¤¹åä¹Ÿè¦è®°ä¸‹æ¥ 
                  for d in dirs:
                      if d == '.git': continue
                      paths_to_check.append(os.path.join(root, d))
                      
                  for f in files:
                      paths_to_check.append(os.path.join(root, f))

              # æ’åºæå…¶é‡è¦ï¼æˆ‘ä»¬å¿…é¡»æŠŠæ·±å±‚çš„ï¼ˆè·¯å¾„é•¿ã€æ–œæ å¤šçš„ï¼‰æ’åœ¨å‰é¢ã€‚
              # å¿…é¡»è¦ä»æœ€åº•å±‚çš„æ–‡ä»¶å¼€å§‹æ”¹åï¼Œå¦‚æœä»ä¸Šå±‚æ–‡ä»¶å¤¹å¼€å§‹æ”¹åï¼Œ
              # åº•å±‚æ–‡ä»¶åŸå…ˆçš„ç‰©ç†è·¯å¾„å°±ä¼šæ‰¾ä¸ç€ï¼Œå¯¼è‡´æŠ¥é”™ã€‚
              paths_to_check.sort(key=lambda x: x.count(os.sep), reverse=True)
              
              total_files = len(paths_to_check)
              print(f"  ğŸ“‚ è¯¥ä»“åº“ç¡¬ç›˜ç‰©ç†å±‚å…±æ¢æµ‹åˆ° {total_files} ä¸ªè·¯å¾„èŠ‚ç‚¹...")
                  
              for file_index, old_full_path in enumerate(paths_to_check):
                  if old_full_path == '.': continue
                  
                  # æˆ‘ä»¬åªå¯¹æœ€åä¸€æ®µï¼ˆæ–‡ä»¶åæˆ–å½“å‰æ–‡ä»¶å¤¹åï¼‰è¿›è¡Œè½¬è¯‘
                  parent_dir = os.path.dirname(old_full_path)
                  old_basename = os.path.basename(old_full_path)
                  
                  new_basename = decode_name(old_basename)
                  
                  if old_basename != new_basename:
                      new_full_path = os.path.join(parent_dir, new_basename)
                      
                      file_progress = (file_index + 1) / total_files * 100
                      try:
                          print(f"    [ç¡¬ä»¶æ‰«ç›˜è¿›åº¦: {file_progress:.1f}%] ğŸ”§ å¼ºåŠ›ä¿®æ­£: [{old_basename}] -> [{new_basename}]")
                      except UnicodeEncodeError: pass
                      
                      # è¿™é‡Œæœ‰æç«¯çš„å‘ï¼šåŒå¼•å·å¦‚æœè¿˜ä¾é™„ç€ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç‰©ç†æ–‡ä»¶æ‰¾ä¸ç€ï¼Œè„±ä¸ªå£³è¯•è¯•
                      actual_old = old_full_path
                      if not os.path.exists(actual_old):
                          stripped_old = os.path.join(parent_dir, old_basename.strip('"'))
                          if os.path.exists(stripped_old):
                              actual_old = stripped_old
                      
                      if os.path.exists(actual_old):
                          try:
                              # å…ˆç»•å¼€ Gitï¼Œåœ¨ç‰©ç†ç¡¬ç›˜å±‚å¼ºç¡¬è¿›è¡Œæ“ä½œ
                              shutil.move(actual_old, new_full_path)
                              fixed_count += 1
                          except Exception as e:
                              print(f"    âŒ é‡å‘½åç‰©ç†ç¡¬ç›˜æ–‡ä»¶å¤±è´¥: {e}")
                  
              if fixed_count > 0:
                  print(f"  âœ… [å®Œæˆ] ç‰©ç†ä¿®æ­£äº† {fixed_count} å¤„è·¯å¾„èŠ‚ç‚¹ï¼Œå‡†å¤‡å‘ŠçŸ¥ Git æ›´æ–°ç´¢å¼•å¹¶æ¨é€...")
                  # -A æŒ‡ä»¤æ˜¯éå¸¸å¼ºå¤§å’Œå½»åº•çš„ï¼šå®ƒå¯ä»¥è®°å½•å·¥ä½œåŒºé‡Œæ‰€æœ‰è¢«æˆ‘ä»¬ç§è‡ªç§»åŠ¨ã€åˆ é™¤æˆ–è€…æ–°å¢çš„ç‰©ç†æ–‡ä»¶
                  subprocess.run(["git", "add", "-A"])
                  subprocess.run(["git", "commit", "-m", "chore: [å¼ºåˆ¶ç‰©ç†æ‰«æ] ä¿®å¤æ¶åŠ£è½¬ä¹‰ç¼–ç è·¯å¾„"])
                  push_result = subprocess.run(["git", "push"], capture_output=True)
                  if push_result.returncode == 0:
                      print(f"  ğŸš€ æ¨é€æˆåŠŸå¹¶è¦†ç›–ï¼")
                  else:
                      print(f"  âŒ æ¨é€å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç”±äºæ²¡æœ‰æƒé™æˆ–è€…æ²¡æœ‰æ–‡ä»¶å˜åŠ¨ï¼")
              else:
                  print(f"  âœ¨ [å®Œæˆ] è¯¥ä»“åº“æ‰«æå®Œæ¯•ï¼Œæœªå‘ç°å¯ç–‘çš„ä¹±ç ç‰¹å¾èŠ‚ç‚¹ã€‚")
                  
              os.chdir('..')
              
              try:
                  shutil.rmtree('temp_repo')
              except:
                  subprocess.run(["rm", "-rf", "temp_repo"])
              
          print("\nğŸ‰ === æ‰€æœ‰ä»“åº“å…¨å±€ç‰©ç†çº§æ‰«æä¿®å¤å®Œæ¯• === ğŸ‰")
          EOF
