name: Global Filename Fixer

on:
  workflow_dispatch: # ä»…æ‰‹åŠ¨è§¦å‘ï¼Œç‚¹å‡» Actions é¡µé¢é‡Œçš„ Run workflow è¿è¡Œ

jobs:
  fix-all-repos:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Fix All Repositories
        env:
          GH_TOKEN: ${{ secrets.MY_PAT }}
          USER_NAME: "hc990275"
          GIT_TERMINAL_PROMPT: 0  # ç»å¯¹ç¦æ­¢ Git åœ¨åå°å¡ä½ç­‰å¾…ä»»ä½•å¯†ç è¾“å…¥
        run: |
          pip install requests
          
          # æ³¨æ„ï¼šæ­¤å¤„çš„ 'EOF' ä½¿ç”¨äº†å•å¼•å·ï¼Œè¿™æå…¶å…³é”®ï¼
          # å®ƒç¡®ä¿äº†ä¸‹æ–¹çš„ Python ä»£ç ä¸­çš„åæ–œæ ï¼ˆå¦‚ '\'ï¼‰ åŸæ ·ä¼ å…¥ Pythonï¼Œä¸ä¼šè¢« Bash æå‰è½¬ä¹‰æ‰ã€‚
          # åŠ ä¸Š -u å‚æ•°å¼ºåˆ¶ python å®æ—¶æ‰“å°æ—¥å¿—ï¼ˆæ— ç¼“å†²ï¼‰ï¼Œä¸ç„¶åœ¨ Actions é‡Œå‰é¢çš„æ‰“å°å¯èƒ½ä¼šè¢«æ†‹ç€
          python -u - <<'EOF'
          import os
          import requests
          import subprocess
          import urllib.parse
          import shutil
          import sys
          import ast

          token = os.getenv('GH_TOKEN')
          username = os.getenv('USER_NAME')
          
          if not token:
              print("âŒ é”™è¯¯ï¼šæœªè®¾ç½® GH_TOKEN ç¯å¢ƒå˜é‡ï¼")
              exit(1)

          headers = {
              'Authorization': f'token {token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          subprocess.run(["git", "config", "--global", "user.name", "GitHub Action Bot"])
          subprocess.run(["git", "config", "--global", "user.email", "action@github.com"])
          # å¼€å¯ quotepath ä¸º true å…¶å®æ˜¯å¸Œæœ›ä¸‡ä¸€è¦ç”¨åˆ° git å‘½ä»¤ï¼Œä¹Ÿä¸è®©å®ƒè‡ªä½œèªæ˜çš„ç¿»è¯‘ï¼
          subprocess.run(["git", "config", "--global", "core.quotepath", "true"])

          # è·å–æ‰€æœ‰ä»“åº“
          repos = []
          page = 1
          while True:
              api_url = f"https://api.github.com/user/repos?per_page=100&type=owner&page={page}"
              print(f"æ­£åœ¨è·å–ç¬¬ {page} é¡µä»“åº“...")
              try:
                  response = requests.get(api_url, headers=headers)
                  response.raise_for_status()
                  page_repos = response.json()
                  if not page_repos:
                      break
                  repos.extend(page_repos)
                  page += 1
              except Exception as e:
                  print(f"âŒ è·å–ä»“åº“åˆ—è¡¨æ—¶å‡ºé”™: {e}")
                  exit(1)

          total_repos = len(repos)
          print(f"âœ… æˆåŠŸè·å–äº† {total_repos} ä¸ªä»“åº“çš„ä¿¡æ¯ï¼Œå‡†å¤‡å¼€å§‹å…¨å±€æ‰«æã€‚")

          def decode_name(name_str):
              """æå…¶ç‹‚æš´çš„å¤šé‡è§£ç å™¨ï¼Œå‰¥é™¤æ‰€æœ‰çš„å¼•å·å’Œè½¬ä¹‰å£³"""
              decoded = name_str
              last_decoded = ""
              
              # æ­»å¾ªç¯ï¼šåªè¦é•¿ç›¸è¿˜åœ¨å˜åŒ–ï¼Œå°±ä¸€ç›´è¯•å›¾æŠŠæ´‹è‘±å‰¥å¼€
              while decoded != last_decoded:
                  last_decoded = decoded
                  
                  # è„±å»ç‰©ç†åŒå¼•å·æˆ–å•å¼•å· (æœ‰äº›ä¹±ç åœ¨å¤´ä¸Šè„šä¸‹å¸¦ç€çœŸå®å¼•å·)
                  if decoded.startswith('"') and decoded.endswith('"') and len(decoded) >= 2:
                      decoded = decoded[1:-1]
                  if decoded.startswith("'") and decoded.endswith("'") and len(decoded) >= 2:
                      decoded = decoded[1:-1]
                  
                  # ä¼˜å…ˆå°è¯• URL è§£ç ã€‚æœ‰äº›è·¯å¾„å˜æˆäº† %22%5C345... %22 å°±æ˜¯åŒå¼•å·ï¼Œ%5C æ˜¯åæ–œæ 
                  if '%' in decoded:
                      try:
                          decoded = urllib.parse.unquote(decoded)
                      except: pass
                      
                  # å¤„ç†å…«è¿›åˆ¶æˆ–åå…­è¿›åˆ¶è½¬ä¹‰ï¼Œå°¤å…¶æ˜¯è¢«å½“åšçº¯å­—ç¬¦ä¸²å†™å…¥ç¡¬ç›˜çš„ \345
                  if '\\' in decoded:
                      try:
                          # ç¬¬ä¸€å±‚å‰¥ç¦» \345 åˆ°å­—èŠ‚
                          temp = decoded.encode('latin-1').decode('unicode_escape')
                          # ç¬¬äºŒå±‚é‡æ–°ç”¨ utf-8 æ„ŸçŸ¥å®ƒ
                          decoded = temp.encode('latin-1').decode('utf-8')
                      except Exception:
                          pass
                      
                      # ç¬¬äºŒæ‰‹å‡†å¤‡ï¼šåˆ©ç”¨ ast è§£æå¸¦æœ‰åŒé‡è½¬ç§»çš„çº¯æ–‡æœ¬ \345
                      if '\\' in decoded:
                          try:
                              mock_str = f'b"{decoded}"'
                              byte_val = ast.literal_eval(mock_str)
                              decoded_ast = byte_val.decode('utf-8')
                              decoded = decoded_ast
                          except Exception:
                              pass
              
              return decoded

          # å¼€å§‹å¤„ç†æ¯ä¸€ä¸ªä»“åº“
          for repo_index, repo in enumerate(repos):
              repo_name = repo['name']
              
              repo_progress = (repo_index + 1) / total_repos * 100
              print(f"\n====================================")
              print(f">>> [æ€»ä½“è¿›åº¦: {repo_index + 1}/{total_repos} ({repo_progress:.1f}%)] æ­£åœ¨å¤„ç†ä»“åº“: {repo_name}")
              print(f"====================================")
              sys.stdout.flush() 
              
              clone_url = repo['clone_url'].replace("https://", f"https://{username}:{token}@")
              
              if os.path.exists('temp_repo'):
                  # å¤„ç†ç”±äº Windows ç­‰æƒé™æ‹’ç»å¼•å‘çš„ç›®å½•åˆ é™¤å¤±è´¥
                  try:
                      shutil.rmtree('temp_repo')
                  except:
                      subprocess.run(["rm", "-rf", "temp_repo"])
              
              if subprocess.run(["git", "clone", "--depth", "1", clone_url, "temp_repo"], capture_output=True).returncode != 0:
                  print(f"è¯¥ä»“åº“å…‹éš†å¤±è´¥: {repo_name}")
                  continue

              os.chdir('temp_repo')
              
              fixed_count = 0
              
              # ã€æ ¸å¿ƒé‡å¡‘ã€‘ï¼šå…¨é‡ç‰©ç†æ¢ç´¢
              paths_to_check = []
              for root, dirs, files in os.walk('.'):
                  if '.git' in root.split(os.sep): continue
                      
                  for d in dirs:
                      if d == '.git': continue
                      paths_to_check.append(os.path.join(root, d))
                      
                  for f in files:
                      paths_to_check.append(os.path.join(root, f))

              # æŒ‰æ·±åº¦æ’åºï¼Œå¿…é¡»å…ˆæ’æ·±çš„æ–‡ä»¶ï¼ˆæœ€é•¿è·¯å¾„åœ¨å‰ï¼‰å†æ’æµ…å±‚çš„æ–‡ä»¶å¤¹
              paths_to_check.sort(key=lambda x: x.count(os.sep), reverse=True)
              
              total_files = len(paths_to_check)
              print(f"  ğŸ“‚ è¯¥ä»“åº“ç¡¬ç›˜ç‰©ç†å±‚å…±æ¢æµ‹åˆ° {total_files} ä¸ªè·¯å¾„èŠ‚ç‚¹...")
                  
              for file_index, old_full_path in enumerate(paths_to_check):
                  if old_full_path == '.': continue
                  
                  parent_dir = os.path.dirname(old_full_path)
                  old_basename = os.path.basename(old_full_path)
                  
                  new_basename = decode_name(old_basename)
                  
                  if old_basename != new_basename:
                      new_full_path = os.path.join(parent_dir, new_basename)
                      
                      file_progress = (file_index + 1) / total_files * 100
                      try:
                          print(f"    [ç¡¬ä»¶æ‰«ç›˜è¿›åº¦: {file_progress:.1f}%] ğŸ”§ å¼ºåŠ›ä¿®æ­£: [{old_basename}] -> [{new_basename}]")
                      except UnicodeEncodeError: pass
                      
                      # å®‰å…¨åœ°è¯†åˆ«è¿™æ–‡ä»¶åˆ°åº•æ˜¯åœ¨ç¡¬ç›˜ä¸Šçš„åŸåã€å¸¦å¼•å·çš„åå­—è¿˜æ˜¯ä»€ä¹ˆå¥‡è‘©åå­—
                      actual_old = None
                      # å‡å¦‚ç‰©ç†åº•å±‚ç¡®å®æ˜¯è¿™æ ·
                      if os.path.exists(old_full_path):
                          actual_old = old_full_path
                      else:
                          # Git æœ‰æ—¶å€™ä¸ç»å…è®¸è¿ç¡¬ç›˜çš„æ–‡ä»¶éƒ½ç»™åŠ ä¸ŠåŒæ’åæ–œçº¿ï¼Œæˆ‘ä»¬è¯•ç€ç”¨ urllib ç­‰æ‰‹æ®µæ‰¾ä»–
                          for fallback in [old_basename.strip('"'), old_basename.replace('\\\\', '\\')]:
                              guess_path = os.path.join(parent_dir, fallback)
                              if os.path.exists(guess_path):
                                  actual_old = guess_path
                                  break
                      
                      if actual_old and os.path.exists(actual_old):
                          try:
                              # æ‰§è¡Œæ“ä½œç³»ç»Ÿå¼ºè¡Œæ”¹å
                              shutil.move(actual_old, new_full_path)
                              fixed_count += 1
                          except Exception as e:
                              print(f"    âŒ é‡å‘½åç‰©ç†ç¡¬ç›˜æ–‡ä»¶å¤±è´¥: {e}")
                  
              if fixed_count > 0:
                  print(f"  âœ… [å®Œæˆ] ç‰©ç†ä¿®æ­£äº† {fixed_count} å¤„è·¯å¾„èŠ‚ç‚¹ï¼Œå‡†å¤‡å‘ŠçŸ¥ Git æ›´æ–°ç´¢å¼•å¹¶æ¨é€...")
                  # -A æŒ‡ä»¤å¼ºè¿« Git å»æ¯”å¯¹æ‰€æœ‰çš„åº•å±‚æ–‡ä»¶çš„å¢åˆ 
                  subprocess.run(["git", "add", "-A"])
                  subprocess.run(["git", "commit", "-m", "chore: [ç»ˆçº§å¼ºåŒ–ç‰ˆç‰©ç†æ‰«æ] ä¿®å¤æ¶åŠ£è½¬ä¹‰ç¼–ç ä¸å¼•ç”¨çš„è·¯å¾„"])
                  push_result = subprocess.run(["git", "push"], capture_output=True)
                  if push_result.returncode == 0:
                      print(f"  ğŸš€ æ¨é€æˆåŠŸå¹¶è¦†ç›–ï¼")
                  else:
                      print(f"  âŒ æ¨é€å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç”±äºæ²¡æœ‰æƒé™æˆ–è€…æ²¡æœ‰æ–‡ä»¶å˜åŠ¨ï¼")
              else:
                  print(f"  âœ¨ [å®Œæˆ] è¯¥ä»“åº“æ‰«æå®Œæ¯•ï¼Œæœªå‘ç°å¯ç–‘çš„ä¹±ç ç‰¹å¾èŠ‚ç‚¹ã€‚")
                  
              os.chdir('..')
              
              try:
                  shutil.rmtree('temp_repo')
              except:
                  subprocess.run(["rm", "-rf", "temp_repo"])
              
          print("\nğŸ‰ === æ‰€æœ‰ä»“åº“å…¨å±€ç‰©ç†çº§æ‰«æä¿®å¤å®Œæ¯• === ğŸ‰")
          EOF
